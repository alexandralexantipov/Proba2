from tkinter import *  # Импортируем все функции из библиотеки tkinter для создания графического интерфейса
from tkinter import messagebox as mb  # Импортируем модуль для работы с всплывающими окнами сообщений под псевдонимом mb


def center_window(window, width, height):  # Объявляем функцию для центрирования окна, принимает окно и его размеры (width x height)
    screen_width = window.winfo_screenwidth()  # Узнаём ширину экрана пользователя в пикселях и сохраняем в переменную screen_width
    screen_height = window.winfo_screenheight()  # Узнаём высоту экрана пользователя в пикселях и сохраняем в переменную screen_height
    x = (screen_width - width) // 2  # Вычисляем координату X для центрирования окна: от ширины экрана отнимаем ширину окна и делим пополам, чтобы получить отступ слева
    y = (screen_height - height) // 2  # Вычисляем координату Y для центрирования окна: от высоты экрана отнимаем высоту окна и делим пополам, чтобы получить отступ сверху
    window.geometry(f"{width}x{height}+{x}+{y}")  # Устанавливаем размер и положение окна в формате "ширина x высота+X+Y"

def book_seat(event=None):  # Объявляем функцию с именем book_seat для бронирования места (event=None позволяет вызывать функцию как по нажатию Enter, так и по кнопке)
    s = seat_entry.get()  # Получаем текст из поля ввода seat_entry и сохраняем в переменную s
    try:  # Начинаем блок обработки исключений для перехвата возможных ошибок
        if seats[s] == "свободно":  # Проверяем, свободно ли выбранное место в словаре seats
            seats[s] = "забронировано"  # Если место свободно, меняем его статус на "забронировано" в словаре seats
            update_canvas()  # Вызываем функцию update_canvas для обновления графического отображения мест
            mb.showinfo("Успех", f"Место {s} успешно забронировано.")  # Показываем всплывающее окно с сообщением об успешном бронировании
        else:  # Если место уже забронировано
            mb.showerror("Ошибка", f"Место {s} уже забронировано.")  # Показываем всплывающее окно с сообщением об ошибке
    except KeyError:  # Перехватываем ошибку KeyError, которая возникает если введенного места нет в словаре seats
        mb.showerror("Ошибка", f"Место {s} не существует.")  # Показываем всплывающее окно с сообщением о несуществующем месте

def cancel_booking(event=None):  # Объявляем функцию с именем cancel_booking для отмены бронирования места
    s = cancel_seat_entry.get()  # Получаем текст из поля ввода cancel_seat_entry и сохраняем в переменную s
    try:  # Начинаем блок обработки исключений
        if seats[s] == "забронировано":  # Проверяем, забронировано ли выбранное место
            seats[s] = "свободно"  # Если место забронировано, меняем его статус на "свободно" в словаре seats
            update_canvas()  # Вызываем функцию update_canvas для обновления графического отображения мест
            mb.showinfo("Успех", f"Бронь на месте {s} успешно отменена.")  # Показываем всплывающее окно с сообщением об успешной отмене брони
        else:  # Если место не забронировано
            mb.showerror("Ошибка", f"Место {s} не забронировано или не существует.")  # Показываем всплывающее окно с сообщением об ошибке
    except KeyError:  # Перехватываем ошибку KeyError
        mb.showerror("Ошибка", f"Место {s} не существует.")  # Показываем всплывающее окно с сообщением о несуществующем месте

def update_canvas():  # Объявляем функцию для обновления графического отображения мест на холсте
    canvas.delete("all")  # Очищаем весь холст от предыдущих элементов
    for i, (seat, status) in enumerate(seats.items()):  # Перебираем все элементы словаря seats, получая индекс i и пару (ключ, значение) для каждого места
        x = i * 40 + 20  # Вычисляем координату X для каждого места: умножаем индекс на 40 (расстояние между местами) и добавляем 20 (отступ слева)
        y = 20  # Задаем фиксированную координату Y для всех мест (20 пикселей от верхнего края холста)
        color = "green" if status == "свободно" else "red"  # Выбираем цвет квадрата: зеленый если место свободно, красный если забронировано
        canvas.create_rectangle(x, y, x+30, y+30, fill=color)  # Рисуем квадрат места размером 30x30 пикселей с вычисленными координатами и выбранным цветом
        canvas.create_text(x+15, y+15, text=seat)  # Добавляем текст с номером места в центр квадрата (координаты центра: x+15, y+15)

window = Tk()  # Создаём главное окно программы
window.title("Бронирование мест")  # Устанавливаем заголовок окна - текст "Бронирование мест" будет показан в верхней строке окна

center_window(window, 400, 310)  # Заменяем строку window.geometry("400x250") на функцию center_window для центрирования окна размером 400x310 (добавляем высоту) пикселей на экране

canvas = Canvas(window, width=400, height=60)  # Создаём холст (область для рисования) шириной 400 пикселей и высотой 60 пикселей внутри главного окна
canvas.pack(pady=10)  # Размещаем холст в окне с вертикальным отступом 10 пикселей сверху и снизу

seats = {f"Б{i}": "свободно" for i in range(1, 10)}  # Создаём словарь мест с помощью генератора словаря: ключи "Б1" до "Б9", все со значением "свободно"
update_canvas()  # Вызываем функцию update_canvas для первоначального отображения мест на холсте

legend_frame = Frame(window)  # Создаём невидимый прямоугольник-контейнер внутри окна для легенды с цветами
legend_frame.pack(pady=10, anchor="w", padx=1)  # Размещаем контейнер легенды с вертикальным отступом 10 пикселей, прижимаем к левому краю (anchor="w") с горизонтальным отступом 1 пиксель

green_frame = Frame(legend_frame)  # Создаём контейнер внутри legend_frame для зеленого элемента легенды
green_frame.pack(side=LEFT, padx=5)  # Размещаем зеленый контейнер слева с горизонтальным отступом 5 пикселей от других элементов

green_canvas = Canvas(green_frame, width=30, height=30, bg="white", highlightthickness=0)  # Создаём холст для зеленого квадрата размером 30x30 на белом фоне без рамки
green_canvas.pack(side=LEFT, padx=5)  # Размещаем зеленый квадрат слева с отступом 5 пикселей от текста
green_canvas.create_rectangle(0, 0, 30, 30, fill="green")  # Рисуем зеленый квадрат размером 30x30 пикселей на холсте

Label(green_frame, text="Свободно", font=("Arial", 9)).pack(side=LEFT, padx=5)  # Создаём текстовую метку "Свободно" шрифтом Arial 9 и размещаем слева с отступом 5 пикселей

red_frame = Frame(legend_frame)  # Создаём контейнер внутри legend_frame для красного элемента легенды
red_frame.pack(side=LEFT, padx=15)  # Размещаем красный контейнер слева с горизонтальным отступом 15 пикселей от зеленого элемента

red_canvas = Canvas(red_frame, width=30, height=30, bg="white", highlightthickness=0)  # Создаём холст для красного квадрата размером 30x30 на белом фоне без рамки
red_canvas.pack(side=LEFT, padx=5)  # Размещаем красный квадрат слева с отступом 5 пикселей от текста
red_canvas.create_rectangle(0, 0, 30, 30, fill="red")  # Рисуем красный квадрат размером 30x30 пикселей на холсте

Label(red_frame, text="Забронировано", font=("Arial", 9)).pack(side=LEFT, padx=5)  # Создаём текстовую метку "Забронировано" шрифтом Arial 9 и размещаем слева с отступом 5 пикселей


seat_entry = Entry(window)  # Создаём поле для ввода текста (Entry) для ввода номера места для бронирования
seat_entry.pack(pady=(20, 5))  # Размещаем поле ввода с вертикальным отступом 20 пикселей сверху и 5 пикселей снизу
seat_entry.focus()  # Устанавливаем фокус ввода на это поле, чтобы пользователь мог сразу начать ввод
seat_entry.bind("<Return>", book_seat)  # Привязываем событие нажатия клавиши Enter к функции book_seat для бронирования по Enter

Button(window, text="Забронировать место", command=book_seat).pack(pady=10)  # Создаём кнопку "Забронировать место" которая при нажатии вызывает функцию book_seat, размещаем с вертикальным отступом 10 пикселей

cancel_seat_entry = Entry(window)  # Создаём поле для ввода текста для отмены бронирования
cancel_seat_entry.pack(pady=5)  # Размещаем поле ввода с вертикальным отступом 5 пикселей
cancel_seat_entry.bind("<Return>", cancel_booking)  # Привязываем событие нажатия клавиши Enter к функции cancel_booking для отмены по Enter

Button(window, text="Отменить бронь", command=cancel_booking).pack(pady=10)  # Создаём кнопку "Отменить бронь" которая при нажатии вызывает функцию cancel_booking, размещаем с вертикальным отступом 10 пикселей

window.mainloop()  # Запускаем главный цикл программы - окно откроется и будет ждать действий пользователя (нажатий кнопок, ввода текста). Окно остаётся открытым и отзывчивым - программа реагирует на все действия пользователя в реальном времени.